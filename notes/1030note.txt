홍성현 : 홍, 송정헌 : 송

예제 7-1
송: 일단 프렌드 함수는 이 함수를 선언하면 클래스의 모든 멤버를 접근할 수 있는 권한을 부여해준다
홍: 사용법은 ppt기준으로 보면 equals는 외부 함수인데 Rect라는 클래스 속에서 쓰고싶을때 equals앞에 friend를 붙이면 사용할 수 있다

송: 예제를 보면 맨 위에 Rect 클래스를 선언하는데 이유가 뭔지 아는가?
홍: Rect 클래스가 선언되기 전에 먼저 참조되는 컴파일 오류를 막기 위해 쓰는거다
위에서 얘기했던 것 처럼 equals함수를 프렌드 함수를 이용해서 선언해보자

송: 그러면 friend bool equals(Rect r, Rect s); 가 되겠네
홍: 이제 equals 함수는 private속성을 가진 변수들, 여기서 width랑 height에 접근할 수 있다
이런식으로 프렌드 함수를 쓰는거고 어떤 느낌인지 감이 온다

7-4
홍: 연산자는 정수, 문자열, 배열합치기등 다양한 곳에서 사용 가능하다
특징으로 정리하자면
1. C++에 본래 있는 연산자만 중복 가능하다 3%%5, 6##7 같은건 컴파일 오류
2. 반드시 클래스와 관계를 가진다
3. 피 연산자 타입이 다른 새로운 연산을 정의한다
4. 피 연산자의 개수를 바꿀 수 없다
5. 연산의 우선 순위 변경이 안된다
6. 모든 연산자가 중복 가능하지 않는다

송: 연산자 함수의 사용법은 
리턴타입 operator연산자(매개변수리스트); 이렇게 사용한다

홍: += 연산자 중복의 경우 Power& operator=(Power op2) 이렇게 쓸 수 있다

7-8
홍: 단항 연산자에 대해서 잘 알고 있는가?
송: 단항 연산자란 피연산자가 하나 뿐인 연사자이다
종류로는 전위 연산자, 후위 연산자가 있다

홍: 전위, 후위가 정확이 어떤 의미인가
송: 코드로 보면 전위 연산자는 !op, ~op, ++op, --op 이고 후위 연산자는 op++,op--이다

홍: 코드로 보니 어떤 느낌인지 바로 알 것같다
송: 그러면 ++연산자의 멤버 함수를 구현해보자

홍: 예제 기준으로 보면 Power& power::operator++() 구현을 한다
그리고 return *this를 해줌으로써 변경된 객체 자신의 참조를 리턴해주면 된다
그리고 메인에서 b=++a; 로 operator++()함수를 호출해주면 된다

7-11
송: 앞에서 배웠던 프렌드 함수와 연산자 함수를 합하면 어떻게 될까
홍: 먼저 power클래스에 public으로 friend Power operator+(int op1, Power op2);
라고 프렌드 선언을 해준 다음 Power operator+(int op1, Power op2_함수를 외부함수로 구현해준다

송: 연산자 함수를 friend로 선언해야하는 이유가 뭘까
홍: kick이랑 punch는 private이기 때문에 얘네한테 접근하기 위해서는 프렌드로 선언해야한다

7-14
송: <<연산자라는 것도 있다
홍: 정수를 더하는 연산자의 느낌이다

*프렌드 함수를 남발하면 안되는 이유
1. 프렌드 함수는 객체지향 캡슐화의 성격을 깨트린다
2. 프렌드 함수를 남용 시 객체지향적인 관점으로 보면 좋지 않다 또한 코드가 복잡해지는 단점이 있다
3. 프렌드 함수는 객체지향적 의미에서 가급적 클래스 안에서만 쓰는게 좋다
4. 프렌드함수를 계속해서 쓰는 것은 좋은 코드는 아니다
뭐든지 적당히 쓰는것이 중요