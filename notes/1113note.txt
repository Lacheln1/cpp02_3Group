가상 함수
-virtual 키워드로 선언된 멤버 함수
virtual : 컴파일러에게 함수에 대한 호출 바인딩을 실행 시간까지 미루도록 지시
사용법: virtual void f()

함수 오버라이딩
-파생 클래스에서 기본 클래스의 가상 함수와 동일한 이름의 함수 선언
1. 기본 클래스의 가상 함수의 존재감 상실시킴
2. 파생 클래스에서 오버라이딩한 함수가 호출되도록 동적 바인딩

*PP 
홍 : 함수 재정의와 오버라이딩의 차이점은 정확히 무엇인가?
송 : 재정의의 경우 PPT 6장을 기준으로 a객체에는 함수f()가 동등한 호출 기회를 가진게 두개다
오버라이딩은 기존 Base의 f()가 아닌 Derived의 f()가 호출된다

>> 가상 함수를 재정의 하는 것이 오버라이딩, 그렇지 않는 경우를 함수 재정의

동적 바인딩
-기본 클래스에 대한 포인터로 가상 함수를 호출하는 경우
-객체 내에 오버라이딩한 파생 클래스의 함수를 찾아 실행

C++ 오버라이딩의 특징
-성공 조건 : 가상 함수 이름, 매개 변수 타입과 개수, 리턴 타입이 모두 일치해야 한다
-오버라이딩 시 virtual 지시어 생략이 가능하다 (가상 함수의 virual 지시어는 상속되고 파생 클래스에서 virtual 생략이 가능하다)
-가상 함수의 접근 지정
> private, protected, public 중 자유롭게 지정이 가능하다

예제 9-3 PP
홍 : 위에서 정리한 내용들을 토대로 9-3에 적용을 하면
f()를 호출했을 때 뭐가 호출이 될까

송 : virtual을 사용하여 오버라이딩 할 경우 base와 derived는 존재감을 잃으니까 grandderived가 호출되지 않을까? 

홍 : 동적 바인딩으로 base와 derived는 존재감을 잃어서 결국 grandDerived의 f()가 호출되는것을 볼 수 있어

범위 지정 연산자 ::
-정적 바인딩 지시
형태>> 기본 클래스::가상함수() 기본 클래스의 가상 함수를 정적 바인딩으로 호출
ex)
class Shape{
public:
	virtual void draw(){...}
};
class Circle : public Shape{
public:
	virtual void draw(){
		Shape::draw() // 기본 클래스의 draw()를 실행한다}};

추상 클래스
순수 가상 함수
-기본 클래스의 가상 함수 목적
함수의 코드가 없고 선언만 있는 가상 멤버 함수
사용법: 멤버 함수의 원형=0;

추상 클래스의 목적
상속에서 기본 클래스의 역할을 하기 위함








